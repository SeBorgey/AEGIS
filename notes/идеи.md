### Заметки:

PySide6  предпочитать Widgets вместо QML
PyInstaller
проверки ruff и mypy

Тестирование ядра и офлайн‑оценка
Набор эталонных ТЗ (50–200 штук) с ожидаемыми результатами:
Примеры: конвертер CSV→XLSX с GUI; менеджер заметок (sqlite); загрузчик изображений; простой HTTP‑клиент; просмотрщик PDF; таймер/помодоро; визуализатор данных (matplotlib).



FastAPI + очередь + статус‑машина задач.
Сделать это отдельным контейнером, а обращаться  к нему по API



Синтаксическая проверка (ast.parse)
Проверка импортов
Pylint/Flake8/Black для качества кода
Проверка типов (mypy)
Проверка безопасности (bandit)


Запуск приложения в headless режиме (QT_QPA_PLATFORM=offscreen) - консольный тестовый запуск без изображения



Определить Pydantic‑схемы ActionCall/ActionResult, завести ActionRegistry

докер только для запуска кода



### План доработок:
- Хотелось бы сделать отдельный фреймворк из того (Action API), что модель может совершать на компьютере. Сделать pydantic модель для этих целей как абстрактный класс.
- Добавить uv.
- Добавить планирование.
- Выполнять код в докере.
- Подробная система логирования. Целый модуль. Выводить в лог не только всё, что происходило в программе, но и записывать полную историю чата с моделью.

Пример Action API:
```
from pydantic import BaseModel, Field
from typing import Any, Dict, Optional

class ActionCall(BaseModel):
    name: str
    params: Dict[str, Any] = Field(default_factory=dict)

class ActionResult(BaseModel):
    success: bool
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    logs: str = ""
    duration_ms: int = 0

class ActionExecutor:
    def __init__(self, policy, registry):
        self.policy = policy
        self.registry = registry  # name -> callable

    def execute(self, call: ActionCall) -> ActionResult:
        self.policy.check(call)  # пути, команды, таймауты
        fn = self.registry.get(call.name)
        if not fn:
            return ActionResult(success=False, error=f"Unknown action {call.name}")
        return fn(**call.params)
```

### Список тулов:
- прочитать файл
- создать файл
- выполнить команду в терминале
- отредактировать файл (заменить старый текст файла новым)
- запустить тесты? (вообще-то можно и автоматически)


Сделать чекер, который будет проверять, насколько код соответствует ТЗ. Его вердикт можно парсить классическим ML. Чтобы потом по результатам парсинга отправлять или не отправлять задание на доработку.
Сделать расширитель ТЗ: если ТЗ написано двумя словами, отдельный промпт будет призван его расширить, чтобы превзойти ожидания пользователя.
Еще один этап нужен для составления плана - планировщик.
